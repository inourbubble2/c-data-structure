# Search
## Comparison of Searching Algorithms
### 최악(탐색, 삽입) | 평균(탐색, 삽입)
#### 순차탐색 | N N | N/2 N
#### 이진탐색 | logN N | logN N/2
#### 이진탐색트리 | N N | logN logN

## Sequential Search for unsorted array
https://github.com/inourbubble2/c-data-structure/blob/main/08-Search/1-SequentialSort.c
> Q. 정렬되지 않은 배열에서 탐색하는 방법은 무엇이 있습니까?
> > A. 순차탐색이 있습니다. 순차 탐색은 탐색 방법 중에서 가장 간단하고 직접적인데, 정렬되지 않은 배열의 항목을 처음부터 마지막까지 하나씩 검사하는 방법입니다. 
> Q. 순차 탐색의 성능을 개선하시오.
> > A. 순차 탐색에서 비교 횟수를 줄일 수 있습니다. 보통의 순차탐색 함수는 반복문에서 리스트의 끝을 테스트하는 비교 연산이 있고 반복문 안에 키 값의 비교 연산이 있는데, 이 연산을 줄이기 위해서 반복문의 탈출 조건을 키 값을 찾을 때까지로 설정할 수 있습니다. 개선된 순차 탐색 알고리즘에서는 탐색에 성공했을 때 인덱스는 찾은 항목의 위치를 가리키고 실패했을 경우는 리스트의 길이를 가르킵니다.

## Search for sorted array
> Q. 정렬된 배열에서 탐색하는 방법으로 무엇이 있습니까?
> > A. 이진탐색과 색인탐색, 보간탐색이 있습니다. 

## Binary Search
https://github.com/inourbubble2/c-data-structure/blob/main/08-Search/2-BinarySearch.c
> Q. 이진탐색에 대해서 설명하시오.
> > A. 이진탐색은 배열의 중앙에 있는 값을 조사하여 찾고자 하는 항목이 왼쪽 또는 오른쪽 부분 배열에 있는지를 알아내어 탐색의 범위를 반으로 줄입니다. 이러한 방법에 의해 10억개의 데이터가 있는 배열에서 단 30번만의 비교로 검색이 완료됩니다. 반면 순차 탐색에서는 평균 5억 번의 비교가 필요합니다.
> Q. 이진 탐색의 효율성을 높이기 위해 무엇을 할 수 있습니까?
> > A. 이진 탐색을 반복적으로 구현할 시 더 효율이 높아집니다.

## Index Search
https://github.com/inourbubble2/c-data-structure/blob/main/08-Search/3-IndexSearch.c
> Q. 색인순차탐색이란 무엇입니까?
> > A. 색인순차탐색은 인덱스라 불리는 테이블을 사용하여 탐색의 효율을 높이는 방법입니다. 인덱스 테이블은 주 자료 리스트에서 일정 간격으로 발췌한 자료를 가지고 있습니다. 색인순차탐색 알고리즘은 우선 인덱스 테이블에서 index[i] <= key < index[i+1]을 만족하는 항목을 찾습니다. 그 항목으로부터 주 자료 리스트에서 순차 탐색을 수행합니다. 이 방법은 탐색 시간을 상당히 줄일 수 있으므로, 파일 처리, 데이터베이스 응용 분야에서 자주 사용됩니다.

## Interpol Search
https://github.com/inourbubble2/c-data-structure/blob/main/08-Search/4-InterpolSearch.c
> Q. 보간 탐색이란 무엇입니까?
> > A. 보간 탐색은 사전이나 전화번호부를 탐색하는 방법과 같이 탐색키가 존재할 위치를 예측하여 탐색하는 방법입니다. 이진 탐색에서 탐색 위치는 항상 (low+high)/2이나, 보간 탐색에서는 키값과 low, high 위치의 값을 고려하여 탐색 위치를 찾습니다. 탐색 위치는 다음 비례식으로 구합니다. (list[high] - list[low]) : (k - list[low]) = (high - low) 즉 값과 위치는 비례한다는 가정하에서 탐색키의 해당되는 위치를 비례식으로 구한 것입니다.

## Binary Search Tree
https://github.com/inourbubble2/c-data-structure/blob/main/08-Search/5-BinarySearchTree.c
Q. 이진탐색트리의 탐색 효율을 높이는 방법에는 무엇이 있습니까?
A. 우선 탐색은 순환적으로 구현하는 것보다 반복적으로 구현하는 게 효율성이 더 높습니다. 그리고 이진탐색트리는 트리가 경사진 경우엔 선형 탐색에 비해 시간적인 이득이 전혀 없는데, 이러한 경우를 방지하기 위해 트리를 균형있게 만드는 AVL 트리, 레드블랙트리와 같은 기법들이 존재합니다.

## AVL Tree
https://github.com/inourbubble2/c-data-structure/blob/main/08-Search/6-AVL_Tree.c
> Q. AVL 트리에 대해서 설명하시오.
> > A. AVL 트리는 왼쪽 서브 트리의 높이와 오른쪽 서브 트리의 높이 차이가 1 이하인 이진 탐색 트리를 말합니다. AVL 트리는 트리가 비균형 상태로 되면 스스로 노드를 재배치하여 균형 상태로 만듭니다. 따라서 항상 균형 트리가 보장되기 때문에 탐색이 O(logN) 시간 안에 끝나게 됩니다. 또한 삽입과 삭제 연산도 O(logN) 시간 안에 할 수 있습니다.

## 2-3 Tree
> Q. 2-3 트리란 무엇입니까?
> > A. 2-3 트리는 차수가 2 또는 3인 노드를 가지는 트리로서 삽입이나 삭제 알고리즘이 AVL 트리보다 간단합니다. 차수가 2인 노드를 2-노드라고 하고, 3인 노드를 3-노드라고 합니다. 2-노드는 일반 이진탐색트리처럼 하나의 데이터와 두 개의 자식 노드를 가지고, 3-노드는 두 개의 데이터와 3개의 자식 노드를 가집니다. 

> Q. 2-3 트리의 탐색 연산에 대해서 설명하시오.
> > A. 2-3 트리의 탐색 연산은 이진 탐색 트리의 알고리즘을 조금만 확장하면 되는데, 노드가 2-노드냐 3-노드냐에 따라서 탐색을 진행합니다. 

> Q. 2-3 트리의 삽입 연산에 대해서 설명하시오.
> > A. 2-3 트리의 노드는 2개의 데이터값을 저장할 수 있습니다. 데이터를 추가할 시 노드에 추가할 수 있을 때까지 데이터는 추가되고 더 이상 저장할 장소가 없는 경우에는 노드를 분리합니다. 현재 노드가 더 이상 데이터를 저장할 공간이 없을 시에는 노드를 3개의 노드로 분리합니다. 중간 값을 한 레벨 위로 올리고, 제일 작은 값을 왼쪽 노드로, 제일 큰 값을 오른쪽 노드로 보냅니다. 
노드가 분리될 때 3가지의 경우가 있습니다. 단말 노드를 분리하는 경우, 비단말 노드를 분리하는 경우, 루트 노드를 분리하는 경우로 나뉩니다. 먼저 단말 노드를 분리하는 경우, 부모노드가 2-노드라면  2개의 노드 중에서 중간 값은 부모 노드로 올라가고 작은값과 큰값을 새로운 노드로 분리합니다. 만약 부모 노드가 3-노드라면 부모 노드가 다시 분리되어야 합니다. 그리고 비단말 노드를 분리하는 경우, 마찬가지로 중간 값을 다시 부모 노드로 올리고 나머지를 별개의 노드로 분리합니다. 서브 트리들도 마찬가지로 분리됩니다. 루트 노드를 분리하는 경우도 이전 과정과 비슷합니다. 루트 노드를 분리하게 되면 새로운 노드가 하나 생기게 되므로 트리의 높이가 하나 증가합니다. 2-3 트리에서 트리의 높이가 증가하게 되는 것은 오직 이 경우 뿐입니다.

## 2-3-4 Tree
> Q. 2-3-4 트리란 무엇입니까?
> > A. 2-3-4 트리는 하나의 노드가 4개의 자식까지 가질 수 있도록 2-3트리를 확장한 것입니다. 4개의 자식을 가지는 노드는 4-노드라고 불리우며 3개의 데이터를 가집니다. 

> Q. 2-3-4 트리의 탐색 연산에 대해서 설명하시오.
> > A. 2-3-4 트리를 탐색하는 것은 2-3 트리의 알고리즘에 4-노드를 처리하는 과정만 추가하면 됩니다.

> Q. 2-3-4 트리의 삽입 연산에 대해서 설명하시오.
> > A. 2-3-4 트리에서 키를 삽입해야 할 단만 노드가 만약 2-노드거나 3-노드면 간단하게 삽입만 하면 됩니다. 다만 4-노드일 시 분할(backward split)이 일어나게 됩니다. 따라서 2-3-4 노드에서 후진 분할 연산을 방지하기 위하여 삽입 노드를 찾는 순회 시에 4-노드를 만나면 미리 분할을 수행합니다. 따라서 후진 분할을 할 필요가 없습니다. 2-3 트리는 삽입 또는 삭제를 위한 순회와 분할과 합병을 위한 순회가 따로 필요합니다. 따라서 2-3 트리에 비해 2-3-4 트리의 장점은 루트에서 단말 노드로 한번만 이동하면서 삽입이나 삭제가 가능하다는 것입니다. 
삽입 시 4-노드에 대하여 다음 3가지 경우를 고려하여 알고리즘을 만들어야 합니다. 4-노드가 루트인 경우, 4-노드의 부모가 2-노드인 경우, 4-노드의 부모가 3-노드인 경우입니다. 노드를 삽입할 때 루트에서 단말 노드로 내려가면서 4-노드를 분할한다면 적어도 4-노드의 부모는 4-노드가 아니라는 것을 알 수 있습니다.

## Red Black Tree
> Q. 레드블랙트리에 대해서 설명하시오.
> > A. 레드블랙트리는 Balanced Binary Search Tree 입니다. 레드블랙트리의 높이는 logN에 바운딩되기에, 레드블랙트리에서 search 연산은 O(logN)의 시간복잡도를 가집니다. 레드블랙트리는 모든 노드에 레드 또는 블랙의 색상을 칠합니다. 다만, 다음과 같은 조건들을 만족해야 합니다. <1. 루트 노드는 블랙이다. 2. 모든 리프 노드는 블랙이다. 3. 노드가 레드이면 그 노드의 자식은 반드시 블랙이다. 4. 루트 노드에서 임의의 리프 노드에 이르는 경로에서 만나는 블랙 노드의 수는 모두 같다.> 여기서 말하는 리프 노드는 일반적으로 말하는 리프 노드와 다른 의미를 가지고 있습니다. 노드가 가진 두 개의 자식 포인터 중 NULL인 것이 있으면 노드를 하나 만들어 그것을 리프 노드라고 부릅니다. 이것은 알고리즘에서 리프 노드가 개입될 때 특수 처리를 하지 않아도 되는 편리함이 있습니다. 위 조건들을 만족하게 되면, 레드블랙트리는 루트노드부터 가장 먼 경로까지의 거리가, 가장 가까운 경로까지의 거리의 2배보다 항상 작습니다. 레드블랙트리는 항상 균형이 잡혀있기에 삽입, 삭제, 탐색 시 최악의 시간복잡도가 트리의 높이에 따라서 결정되기에 보통의 이진탐색트리보다 효율적입니다.

> Q. 레드블랙트리의 탐색, 삽입 연산에 대해서 설명하시오.
> > A. 우선 레드블랙트리의 탐색은 이진탐색트리에서 탐색하는 것과 동일합니다. 다만 삽입은 이진탐색트리와 유사하지만 여러가지 제약 조건이 많습니다. 이진탐색트리와 같이 먼저 삽입할 노드를 탐색한 다음 NULL인 부분에 노드를 삽입하면 되는데, 레드블랙트리의 규칙에 맞도록 만들어주어야 합니다. 규칙을 적용하는 경우는 현재 노드가 레드노드이면서 부모도 레드노드인 경우입니다. (레드노드의 자식은 블랙노드여야 하기 때문입니다.) 조건은 세 가지가 있습니다. 부모의 형제 노드가 레드노드인 경우, 부모의 형제 노드가 블랙 노드이면서 현재 노드의 키값이 부모의 키값과 부모의 부모의 키값 사이인 경우, 부모의 형제 노드가 블랙 노드이면서 현재 노드의 키값보다 부모의 키값과 부모의 부모의 키값이 큰 경우 혹은 작은 경우입니다.
먼저 부모의 형제 노드가 레드 노드인 경우, 부모, 부모의 형제, 부모의 부모의 색을 모두 바꿉니다. 이럴 경우 부모 노드와 부모의 형제 노드를 블랙 노드로 바꿉니다. 그리고 부모의 부모는 레드 노드로 바꿉니다. 
두번째로 부모의 형제 노드가 블랙 노드이면서, 현재 노드 키값이 부모 키값과 부모의 부모 키값 사이인 경우, 현재 노드와 부모 노드를 회전시킵니다. 현재 노드가 부모가 되게끔 하고, 기존 부모 노드를 현재 노드의 오른쪽 자식이 되게끔 만듭니다. 
세번째로 부모의 형제 노드가 블랙 노드이면서, 현재 노드 키값이 부모의 키값과 부모의 부모 키값보다 크거나 작은 경우, 부모 노드와 부모의 부모 노드를 회전시키고 색깔을 바꿉니다. 현재 부모를 부모의 부모 자리로 옮기고, 부모의 부모는 현재 부모 노드의 자식이 되도록 만듭니다. 그리고 부모의 형제를 부모의 부모 노드의 자식이 되도록 만듭니다. 그런 뒤 기존 부모 노드는 블랙 노드로, 기존 부모의 부모 노드는 적색이 되도록 합니다. 그런 뒤 현재 노드를 기존 부모 노드의 자식이 되게끔 만듭니다. 이렇게 원소를 추가하면 레드블랙트리의 모든 성질을 만족합니다. 

