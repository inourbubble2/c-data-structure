# Sortion

## Comparison of sorting algorithms
### 알고리즘 / 최선 / 평균 / 최악
#### 선택 정렬 O(n) O(n^2) O(n^2)
#### 삽입 정렬 O(n^2) O(n^2) O(n^2)
#### 버블 정렬 O(n^2) O(n^2) O(n^2)
#### 쉘 정렬 O(n) O(n^1.5) O(n^1.5)
#### 퀵 정렬 O(nlog2^n) O(nlog2^n) O(n^2)
#### 히프 정렬 O(nlog2^n) O(nlog2^n) O(nlog2^n)
#### 합병 정렬 O(nlog2^n) O(nlog2^n) O(nlog2^n)
#### 기수 정렬 O(dn) O(dn) O(dn)

## Selection Sort
https://github.com/inourbubble2/c-data-structure/blob/main/07-Sortion/1-SelectionSort.c
> Q. 선택 정렬의 방법과 복잡도에 대해서 설명하시오.
> > A. 선택 정렬은 리스트에서 가장 작은 숫자를 선택하여 정리되지 않은 열의 왼쪽 끝의 숫자와 교환하는 것을 반복하는 정렬 방법입니다. 선택 정렬은 O(n^2)의 복잡도를 가지고 있습니다. 선택 정렬의 이동 횟수는 3(n-1)로 정해져있습니다. 

## Insertion Sort
https://github.com/inourbubble2/c-data-structure/blob/main/07-Sortion/2-InsertionSort.c
> Q. 삽입 정렬에 대해서 설명하시오.
> > A. 삽입 정렬은 정렬되어 있는 리스트 안에 새로운 레코드를 적절한 위치에 삽입하는 것을 반복합니다. 처음에는 왼쪽 끝의 숫자를 정렬이 끝났다고 간주한 뒤, 작업하지 않은 숫자 중에서 왼쪽 끝의 숫자를 꺼내서 작업이 끝난 숫자와 비교합니다. 그리고 왼쪽의 숫자가 크면 두 개의 숫자를 바꾸는 작업을 자신보다 작은 숫자가 나타나거나 왼쪽 끝에 도달할 때까지 반복합니다. 
> > A. 삽입 정렬의 복잡도는 입력 자료의 구성에 따라 달라지는데, 입력 자료가 이미 정렬되어 있는 경우에 복잡도는 O(n) 이고, 입력 자료가 역순으로 정렬되어 있을 경우에는 O(n^2)의 복잡도를 가집니다. 삽입 정렬은 비교적 많은 레코드의 이동을 요구하기 때문에 레코드 양이 많은 경우에는 적합하지 않습니다. 하지만 매우 간단하고 자료가 이미 정렬되어 있는 경우엔 효율적이기 때문에 자주 사용됩니다.

## Bubble Sort
https://github.com/inourbubble2/c-data-structure/blob/main/07-Sortion/3-BubbleSort.c
> Q. 버블 정렬의 방법과 복잡도에 대해서 설명하시오.
> > A. 버블 정렬은 인접한 2개의 레코드를 비교하여 크기가 순서대로 되어 있지 않으면 교환하는 비교-교환 과정을 리스트의 왼쪽부터 끝까지 진행합니다. 버블 정렬은 최선, 평균, 최악에 관계 없이 일정한 O(n^2)의 복잡도를 가집니다. 버블 정렬은 교환 작업이 많은데, 자료의 교환(swap) 작업이 자료의 이동(move) 작업보다 복잡하기 때문에 잘 쓰이지 않는 정렬입니다. 

## Shell Sort
https://github.com/inourbubble2/c-data-structure/blob/main/07-Sortion/4-ShellSort.c
> Q. 쉘 정렬의 방법과 복잡도에 대해서 설명하시오.
> > A. 쉘 정렬은 정렬할 리스트를 일정한 기준에 따라 분류하여 부분 리스트로 만들고 각 부분 리스트를 삽입 정렬을 통해 정렬합니다. 이후 부분 리스트의 간격이 1이 될때까지 반복합니다. 쉘 정렬의 복잡도는 최악의 경우 O(n^2)이고, 평균의 경우 O(n^1.5)입니다. 

## Merge Sort
https://github.com/inourbubble2/c-data-structure/blob/main/07-Sortion/5-MergeSort.c
> Q. 합병정렬의 방법과 복잡도에 대해 설명하시오.
> > A. 합병정렬은 하나의 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬한 다음 두 개의 부분 리스트를 합하여 전체를 정렬시키는 알고리즘입니다. 합병 정렬은 분할 정복(Divide and conquer)에 바탕을 두고 있습니다. 합병정렬은 최선, 평균, 최악의 경우 모두 O(n^log2n)의 복잡도를 가지고 있습니다. 합병정렬은 임시 배열이 필요하고 레코드의 크기가 큰 경우엔 이동 횟수가 많으므로 시간적 낭비를 초래한다는 단점을 가지고 있지만, 레코드를 연결리스트로 구성할 경우 다른 정렬들보다 효율적입니다.

## Quick Sort
https://github.com/inourbubble2/c-data-structure/blob/main/07-Sortion/6-QuickSort.c
> Q. 퀵 정렬의 방법과 복잡도에 대해서 정의하시오.
> > A. 퀵 정렬은 합병정렬과 비슷하게 분할-정복법을 사용합니다. 다만 퀵정렬은 피벗이라는 요소가 필요합니다. 평균적인 경우 퀵 정렬은 O(nlog^2n)의 복잡도를 가지지만, 최악의 경우 O(n^2)의 복잡도를 가집니다. 
> Q. 퀵 정렬을 개선하는 방법을 말하시오.
> > A. 퀵 정렬은 피봇 값을 선택하는 게 매우 중요합니다. 그래서 랜더마이즈 퀵 소트를 사용하여, 피봇을 랜덤한 값으로 선택하면 O(n log n)의 안정적인 복잡도를 가질 수 있습니다. 혹은 피봇을 배열의 가운데 값으로 선택하여도 좋은 성능을 기대할 수 있습니다.

## Radix Sort
https://github.com/inourbubble2/c-data-structure/blob/main/07-Sortion/7-RadixSort.c
> Q. 기수정렬의 방법과 복잡도에 대해서 설명하시오.
> > A. 기수정렬은 십진수에서 각 자릿수가 0에서 9까지의 값만 가지는 것에 착안하여 입력 데이터를 자리수의 값에 따라 정렬합니다. 특별한 점은 비교 연산을 전혀 사용하지 않는 것입니다. 기수정렬에서 각각의 버킷에 먼저 들어간 숫자들은 먼저 나와야하기 때문에 큐가 사용됩니다. 기수정렬에서 정수가 d개의 자리수를 가지고 있다고 치면 O(d*n)의 복잡도를 가집니다. 그러나 일반적으로 컴퓨터 안에서 정수의 크기를 제한하므로, d는 n에 비해 아주 작은 수가 되기에 O(n)이라고 하여도 무방합니다. 

## Counting Sort
https://github.com/inourbubble2/c-data-structure/blob/main/07-Sortion/8-CountingSort.c
> Q. 계수 정렬의 방법과 복잡도에 대해서 설명하시오.
> > A. 계수 정렬은 데이터의 크기를 기준으로 정렬하는 방식입니다. 데이터의 정렬 범위가 정해져있을 때 O(n)의 시간 복잡도로 퀵 정렬보다 빠릅니다. 하지만 숫자 외에는 정렬할 수 없다는 단점이 있습니다. 그리고 숫자의 범위가 크고 분포가 넓을 경우 메모리 비효율이 발생합니다. 
